/*----------------------------------------------------------------
 *  Author:        Ketan Nayak
 *  Written:       2/9/2015
 *
 *  Purpose:  Create a generic data type Deque
 *  Detail:  A double-ended queue or deque (pronounced "deck") is a generalization 
 *  of a stack and a queue that supports inserting and removing items from either 
 *  the front or the back of the data structure
 *  Implementation: Using a doubly-linked list
 *  
 *  Assignment here: http://coursera.cs.princeton.edu/algs4/assignments/queues.html
 *  Check-list here: http://coursera.cs.princeton.edu/algs4/checklists/queues.html
 *----------------------------------------------------------------*/
import java.util.Iterator;

public class Deque<Item> implements Iterable<Item> {
	
	private Node first; //Stores the first node of the linked list
	private Node last; //Stores the last node of the linked list
	private int N; //Stores the current size of the linked list
	
	//Implements a Node class for a doubly linked list
	private class Node{
		Item item;
		Node next;
		Node previous;
	}
	
	//Creates an empty linked list with one node
	public Deque(){
		
		first = new Node();
		last = new Node();
		
		first.next = null; //Both the next and previous links are null
		first.previous = null;
		
		last = first; //We only have one node	

	}
	
	//Method to check if the Deque is empty
	public boolean isEmpty(){
		return N==0;
	}
	
    //Method to get the size of the items in the Deque
	public int size(){
		return N;	
	}
	
	//Add item to the start of the list
	public void addFirst(Item item){
		
		//throw an exception if item is null
		if (item == null) throw new NullPointerException("You can't add a null item");
		
		if (isEmpty()){
			
			//If list is empty, then we just add the item to the existing node
			last.item = item;
			N++;
			
		} else {
			
			//If list is not empty then add a node to the beginning
			Node oldfirst = first;
			first = new Node();
			first.item = item;
			first.previous = null;
			first.next = oldfirst;
			oldfirst.previous = first;
			N++;
			
		}
		
	}
	
	//Add item to the end of the list
	public void addLast(Item item){
		
		//throw an exception if item is null
		if (item == null) throw new NullPointerException("You can't add a null item");
		
		if (isEmpty()){
			
			//If is empty, then we already have a node, into which we can add an item
			last.item = item;
			N++;
			
		} else {
			
			//Otherwise we need to add a new node to the end
			Node oldlast = last;
			last = new Node();
			last.item = item;
			last.next = null;
			last.previous= oldlast;
			oldlast.next = last;
			N++;
		}
	
	}
	
	public Item removeFirst(){
		
		Item item = first.item;
		first = first.next;
		if (isEmpty()) last = null;
		N--;
		return item;	
	}
	
	public Item removeLast(){
		
		Item item = last.item;
		
	}
	
	public Iterator<Item> iterator(){
		return new ListIterator();	
	}
	
	private class ListIterator implements Iterator<Item>
	{
		private Node current = first;
	
		public boolean hasNext(){ 
			return current != null; 
		}
		
		//Remove method that needs to be a part of the iterator, but throws exception
		public void remove() { 
			throw new UnsupportedOperationException("This operation is unsupported");
		}
		
		public Item next()
		{
			Item item = current.item;
			current = current.next;
			return item;
		}
	}
	
	
	public static void main(String args[]){
		
	}
	
	
}
